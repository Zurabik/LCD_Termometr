/*
 * nec.c
 *
 * Created: 31.01.2015 15:26:41
 *  Author: Vadim
 */ 
#include "nec.h"
#if (IR_IS_USED==1)

unsigned char tick = 0;			//буфер таймера2
unsigned char IR_n_bit = 0;		//подсчет номера импульса
volatile char timer2_10_ms = 0;	//подсчет времени для определения окончания посылки 10мс

void IR_Init()
{
	cli();

	//=====INT0
	INT0_DOWN; 						// настраиваем прерывание INT0 на срабатывание при спаде сигнала
	EIMSK=(1<<INT0);				// настраиваем прерывание INT0 на работу
	//=====INT0

	//=====TIMER2
	Reset_T2;					// выставляем начальное значение TCNT2
	TIMSK2 = (1<<TOIE2);		// разрешаем прерывание по переполнению таймера
	//=====TIMER2
	sei();
}
/*
 * Имя                   :  Прерывание "TIMER2_OVF_vect" по переполнению счетчика №2
 * Описание              :  Производит остановку и сброс счетчика №2 если в течении 200 мс не приходили сигналы с ИК приемника
 * Аргумент(ы)           :  нет
 * Возвращаемое значение :  нет
 */
ISR( TIMER2_OVF_vect )
{
 	timer2_10_ms++;
 	if (timer2_10_ms>20)// если в течении 200 мс не приходили сигналы с ИК приемника
 	{
 		Stop_T2;		//	остановка Т2
		Reset_T2;		//	сброс Т2
 	}
}

uint8_t IR_Check_NEC()
{
	tick = TCNT2;
	Reset_T2;
	Start_T2_1024;
	if (tick >= START_13_5ms_min && tick < START_13_5ms_max)					//если случилось от 139 до 150 тиков (4.5 ms)
	{
		START = 1;																//фиксируем стартовое условие
		REPEAT = 0;																//обнуляем флаг повтора
		//ADDR1 = ADDR0 = CMD0 = CMD1 = CH_MESSAGE= 0;								//и ранее полученную команду и адрес
		IR_MESSAGE_i32= 0;
		//return;
		//send_Uart_str("start");
	}
	if (tick >= REPEAT_11_2ms_min && tick < REPEAT_11_2ms_max)                      //если случилось от 116 до 138 тиков (2.5-4.5 ms)
	{
		REPEAT = 1;                                                //фиксируем флаг повтора
		START = 0;                                                 //обнуляем флаг стартового условия
		//Reset_T2;
		//send_Uart_str("repeat");
	}
	if (START)
	{
		if (tick >= _1_2_22ms_min && tick < _1_2_22ms_max)     //если случилось от 22 до 115 тиков
		{
			B_CNT++;                                                        //приняли "1" и увеличили счетчик битов
			IR_MESSAGE_i32= (IR_MESSAGE_i32>>1)+0x80000000;
			//if (B_CNT < 9) ADDR1 = (ADDR1 << 1) + 1;                      //первый байт - прямой адрес
			//if (B_CNT >= 9 && B_CNT < 17) ADDR0 = (ADDR0 << 1) + 0;       //второй байт - инверсный адрес
			//if (B_CNT >= 16 && B_CNT < 25) CMD1 = (CMD1 << 1) + 1;        //третий байт - прямая команда
			//if (B_CNT >= 24) CMD0 = (CMD0 << 1) + 0;                      //четвертый байт - инверсная команда
			//send_Uart_str("1");
		}
		if (tick >= _0_1_11ms_min && tick < _0_1_11ms_max)                              //если случилось от 10 до 21 тика
		{
			B_CNT++;                                                        //приняли "0" и увеличили счетчик битов
			IR_MESSAGE_i32 = (IR_MESSAGE_i32>>1);
			//if (B_CNT < 9) ADDR1 = (ADDR1 << 1);                          //далее - аналогично по байтам
			//if (B_CNT >= 9 && B_CNT < 17) ADDR0 = (ADDR0 << 1)+1;
			//if (B_CNT >= 16 && B_CNT < 25) CMD1 = (CMD1 << 1);
			//if (B_CNT >= 24) CMD0 = (CMD0 << 1)+1;
			//send_Uart_str("0");
		}
	}
	tick = 0;                                                               //обнулили тики
	if (B_CNT == 32)                                                        //если приняли уже 4 байта
	{
		//                 if ((addr_1+addr_0) == 0xFF) addr = addr_0;      //закомментировано, потому как в пульте First
		//                         else addr = 0;                           //16-bit адрес 0x6120, т.о. проверка адреса не проходит
		if (((ADDR0+ADDR1) == 0xFF)&&((CMD0+CMD1) == 0xFF))					//проверили правильность приема команды
		{
			return CMD0;												//возвращает код нажатой кнопки
			//message_unit[0].IR_ST = 1;										//определили что нажата кнопка пульта по протоколу NEC и установили флаг нажатия кнопки
		}
		B_CNT = 0;															//обнулили счетчик битов
		START = 0;															//сбросили стартовое условие
		REPEAT = 0;															//сбросили повтор
		Stop_T2;															//остановили таймер
		Reset_T2;
	}
	else
	{
		return 0xFF;
	}
}

/*
 * Имя                   :  Прерывание "INT0_vect" по спаду сигнала 
 * Описание              :  Проверяем код нажатой кнопки и устанавливаем соответствующие флаги
 * Аргумент(ы)           :  нет
 * Возвращаемое значение :  
							Устанавливает флаг нажатия кнопки
 */
ISR(INT0_vect)																	
{
	//PORTB=(1<<PINB1);
	if (IR_Check_NEC()!=0xff)								//получили код кнопки определили что нажата кнопка пульта по протоколу NEC
	{
		message_unit[0].IR_ST = 1;							// установили флаг нажатия кнопки
		message_unit[0].GET_IR_DATA_i32 = IR_MESSAGE_i32;	//записали данные посылки в структуру "message_unit" смотри Message.h
		//message_unit[0].LOAD_ST = 1;						// установили флаг записи в сдвиговый регистр
	} 

	//;
//	cli();
														//обнулили таймер 
}
#endif